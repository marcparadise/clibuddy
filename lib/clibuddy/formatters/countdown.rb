# More a renderer than a formatter, but it'll do for now

# TODO - I expect we'll want a module schema along the lines of:
#        CLIBuddy::UIComponents::Countdown
module CLIBuddy::Formatters
  class Countdown
    attr_reader :term_width, :cursor
    def initialize(duration, message)
      require 'tty/screen'
      @duration = duration
      @message = message
      # TODO copypasta from builder, consolidate
      @term_width = [TTY::Screen.width, 80].min
      @cursor = TTY::Cursor
    end

    def render
      require 'tty/cursor'
      require 'pastel'
      pastel = Pastel.new
      # Make room in case we're at bottom of screen:
      print "\n\n\n"
      print cursor.save
      print cursor.hide
      # Center among our newly created blank lines
      # for some reason that I didn't care to explore cursor.move(0,-2) isn't.
      print cursor.prev_line
      print cursor.prev_line
      print cursor.clear_screen_down

      # Cetner the message across available width:
      print cursor.column(term_width/2 - @message.length / 2)
      print format(@message)
      print cursor.next_line
      print cursor.next_line

      x = @duration
      while x >= 0
        if x == 0
          # Clear out our previous runs
          print cursor.clear_lines(3, :up)
          print cursor.column(0)
        else
          label = x.to_int == 1 ? "second" : "seconds"
          # Calc length separately since we don't want escape characters
          # generated by pastel.decorate to through off our visible string length.
          len  = "Continuing in #{x.to_int} #{label}".length
          # print cursor.clear_line
          print cursor.column(term_width/2 - len/2)
          print format(pastel.decorate("Continuing in #{x.to_int} #{label}", :magenta, :bold))
          if x > 0
            if breakable_sleep(1) == :interrupted
              x = 0
            end
          end
        end
        x-=1
      end
    ensure
      print cursor.show
      print cursor.restore
    end

    def breakable_sleep(time)
      sleep(time * (1.0))
    rescue Interrupt
      :interrupted
    ensure
      # Don't leave term in a bad state
      print cursor.show
      print cursor.restore
    end
  end
end

